{"meta":{"title":"窄门","subtitle":"","description":"","author":"zzx","url":"https://zzx-dear.github.io","root":"/"},"pages":[{"title":"about","date":"2024-05-12T05:59:41.000Z","updated":"2024-05-12T05:59:41.804Z","comments":true,"path":"about/index.html","permalink":"https://zzx-dear.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-05-12T05:50:09.000Z","updated":"2024-05-12T05:50:09.955Z","comments":true,"path":"categories/index.html","permalink":"https://zzx-dear.github.io/categories/index.html","excerpt":"","text":""},{"title":"timeline","date":"2024-05-12T05:59:24.000Z","updated":"2024-05-12T05:59:24.706Z","comments":true,"path":"timeline/index.html","permalink":"https://zzx-dear.github.io/timeline/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-06-15T16:34:27.000Z","updated":"2024-05-12T06:18:11.070Z","comments":true,"path":"link/index.html","permalink":"https://zzx-dear.github.io/link/index.html","excerpt":"","text":".links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } ZW’s blog 这是一个分享IT技术的小站。 越行勤's Blog 努力学习的小菜鸟"},{"title":"myself","date":"2024-05-12T05:59:54.000Z","updated":"2024-05-12T05:59:54.427Z","comments":true,"path":"myself/index.html","permalink":"https://zzx-dear.github.io/myself/index.html","excerpt":"","text":""},{"title":"messageboard","date":"2024-05-12T05:50:30.000Z","updated":"2024-05-12T05:50:30.266Z","comments":true,"path":"messageboard/index.html","permalink":"https://zzx-dear.github.io/messageboard/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-05-12T05:49:03.000Z","updated":"2024-05-12T05:49:03.541Z","comments":true,"path":"tags/index.html","permalink":"https://zzx-dear.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"高斯数据库数据操作实例","slug":"高斯数据库数据操作实例","date":"2024-05-14T13:13:49.000Z","updated":"2024-05-14T14:12:01.259Z","comments":true,"path":"2024/05/14/高斯数据库数据操作实例/","permalink":"https://zzx-dear.github.io/2024/05/14/%E9%AB%98%E6%96%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"高斯数据库 数据查询实例（一） 空值对结果的影响（例如在计算sum, avg, min集函数时系统如何处理空值属性）？ 在gauss数据库中空值不做处理 *储备知识：*（一）索引的概念​ 索引（在MySQL中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构，这也是索引最基本的功能。 ​ 索引对于良好的性能非常关键。数据量越大时，索引对性能的影响也越重要，好的索引可以将查询性能提高几个数量级。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但是在数据量逐渐增大时，糟糕的索引会使MySQL的性能急剧的下降。 ​ 索引优化是查询性能优化最有效的手段。 ​ 如果想要在一本书中找到某个特定主题，一般会先看书的目录，找到对应的页码，然后直接翻到对应的页码即可查看。存储引擎用类似的方法使用索引，首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。简单的说，数据库索引类似于书前面的目录，能加快数据库的查询速度。 （二）索引的类别按照功能逻辑区分，目前主要有以下索引类型： 1、主键索引​ 数据列不允许重复，不允许为NULL，一个表只能有一个主键。 ALTER TABLE table_name ADD PRIMARY KEY (column); 2、普通索引​ MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和NULL值。一个表允许多个列创建普通索引。 ALTER TABLE table_name ADD INDEX index_name (column); 3、唯一索引​ 索引列中的值必须是唯一的，但是允许NULL值。建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。一个表允许多个列创建唯一索引。 ALTER TABLE table_name ADD UNIQUE (column); 4、全文索引​ 主要是为了快速检索大文本数据中的关键字的信息。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引，基于倒排索引，类似于搜索引擎。 ALTER TABLE table_name ADD FULLTEXT (column); 5、前缀索引​ 在文本类型如BLOB、TEXT或者很长的VARCHAR列上创建索引时，可以使用前缀索引，数据量相比普通索引更小，可以指定索引列的长度，但是数值类型不能指定。 ALTER TABLE table_name ADD KEY(column_name(prefix_length)); 6、组合索引​ 指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀原则。 主键索引、普通索引、唯一索引等都可以使用多个字段形成组合索引。例如，ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3 ); （三）非聚簇索引与聚簇索引的区别聚簇索引和非聚簇索引的主要区别在于它们的存储方式、查找效率以及数据行修改的影响。 存储方式不同：聚簇索引的叶子节点直接包含了数据行，这意味着数据和索引在一起存储。在InnoDB中，主键默认就是聚簇索引。非聚簇索引的数据行和索引结构是分开存储的，叶子节点包含指向数据行的指针。 查找效率不同：聚簇索引由于其数据和索引紧耦合的特性，在查找特定值或范围的查询时非常高效。非聚簇索引在查找数据时需要进行额外的物理读取，因此在某些情况下会比聚簇索引慢一些。 数据行修改的影响不同：当数据行发生修改时，聚簇索引可能需要移动或调整相应的数据行位置，这可能会导致页分裂等问题。而非聚簇索引只需更新索引树和数据页，不会影响到其他数据行的位置。 ​ 此外，在MySQL的InnoDB存储引擎中，除了主键作为聚簇索引外，其他创建的索引如复合索引、前缀索引、唯一索引等都是非聚簇索引，也被称为辅助索引。这些辅助索引的叶子节点存储的不是数据的物理位置，而是主键值，通过主键值再去查找实际的数据行。 ​ 综上所述，聚簇索引和非聚簇索引在存储方式、查找效率等方面上有明显的差异。聚簇索引适合用于频繁访问的数据，而非聚簇索引则适用于插入操作频繁的场景。在设计数据库表和索引时，需要根据具体的应用场景和查询需求来选择合适的索引类型。 （二）注意查看查询执行计划：如果查看的属性列上有索引和没有索引，系统是读取数据的方式有何不同？Clsnum列上没有索引时： 根据这个执行计划，我们可以知道这个查询是一个全表扫描，针对GAUSSDBTEST用户的CLASS表进行操作。 为Clsnum列上创建索引后（CREATE INDEX index_clsnum ON class(clsnum);）： 根据这个执行计划，可以推断出以下信息： 1、这个查询是通过使用名为INDEX_CLSNUM的索引来访问名为CLASS的表。 2、索引访问方式是FAST FULL SCAN，即快速全扫描，这通常意味着将扫描整个索引以找到匹配的行。 *例外：在有些数据库中如果一个表上建立了一个索引，那么在这个表上的所有查询都将是索引查询，都会利用这个索引去读取表中的数据，不管索引所属于的属性列是否被涉及。* （三）为什么有时候即使使用了Order by操作，但查询计划里并没有相应的操作？对于distinct也有类似的情况。 用主键clsno作为Order by的条件时，在执行计划中会发现并没有执行Order by操作； 利用tchno作为order by的条件的时候，在执行计划里就会有相应order by的操作。 从上面两个对比，我们可以知道，当order by后面的属性上已经有索引使数据按照顺序存放的时候，再用order by不会再执行一次排序工作；但是当order by后面的属性列上没有相应的约束时，当这个属性列作为order by的条件，会进行一次sort排序工作。 （四）对于distinct的情况：如果要求distinct的属性列上已经没有是没有重复的了，那么就不会再执行一次distinct操作；如果这个属性列上本身并没有使它不重复的约束，那么会执行一次distinct操作。（没有使它不重复的约束） （添加后） （五）关于链接查询​ 通过查询相关信息我们知道，系统只辨别等值连接，如果要进行自然连接，我们应该在查询语句中自己输入好select的条件，例如我们上面写出elective.courNo,elective.elcTime,elective.elcGrade，而不是只写出elective.*，由系统去辨别这是自然连接，然后执行查询。等值连接和自然连接是数据库中用于关联两个表的两种不同的连接方式。具体区别如下： 连接条件：等值连接不要求连接的属性值完全相同，而自然连接要求进行比较的两个关系中必须有相同的属性组，即值域必须相同。 重复属性处理：等值连接不会去掉重复属性，而自然连接会去掉重复的属性列。这意味着自然连接实际上是去除了重复列的等值连接。 公共属性要求：等值连接要求相等的分量，不一定是公共属性；而自然连接要求相等的分量必须是公共属性。 操作结果：自然连接在等值连接的基础上进行投影操作，去掉了S中的公共属性列。当两个关系没有公共属性时，自然连接就转化成笛卡尔积。 ​ 总的来说，自然连接是一种特殊类型的等值连接，它在等值连接的基础上进行了额外的属性去除操作。在实际使用中，根据查询需求的不同选择合适的连接类型是非常重要的。 相关嵌套查询和非相关嵌套查询是SQL中两种常见的嵌套查询方式。 相关嵌套查询（Correlated Nested Query）： - 相关嵌套查询是指子查询的结果依赖于外部查询的某个值或条件。 - 在执行相关嵌套查询时，外部查询的每一行都会执行一次子查询，因此可能导致性能问题。 非相关嵌套查询（Non-correlated Nested Query）： - 非相关嵌套查询是指子查询的结果不依赖于外部查询的任何值或条件。 - 在执行非相关嵌套查询时，子查询只会执行一次，然后将结果用于外部查询。 总结：相关嵌套查询和非相关嵌套查询的主要区别在于子查询的结果是否依赖于外部查询的值或条件。相关嵌套查询可能导致性能问题，而非相关嵌套查询则更加高效。 IN、EXISTS、ANY、ALL和SOME在SQL中都是用来处理子查询的关键字，它们之间存在一定的等价关系。以下是具体的分析： - IN：当主查询中的值在子查询返回的结果集中时，IN条件为真。它相当于使用等于（&#x3D;）比较运算符与子查询结果集中的每一个值进行比较。 - EXISTS：当子查询至少返回一行数据时，EXISTS条件为真。它不对子查询的结果集进行缓存，只关心是否有结果返回。如果子查询没有返回任何行，EXISTS返回false。 - ANY（或SOME）：当主查询中的值满足子查询结果集中的任何一个值时，ANY（或SOME）条件为真。它相当于使用比较运算符（如&#x3D;、&gt;、&lt;等）与子查询结果集中的每一个值进行比较。 - ALL：当主查询中的值满足子查询结果集中所有值的条件时，ALL条件为真。它要求主查询中的值必须同时满足子查询结果集中所有值的比较条件。 ​ 总的来说，这些关键字在处理子查询时有着不同的应用场景和效率考虑，选择合适的关键字可以帮助提高查询的性能。在实际使用时，需要根据具体的数据和查询需求来选择最合适的关键字。","categories":[],"tags":[]},{"title":"无敌暴龙队","slug":"无敌暴龙队","date":"2024-05-10T11:34:23.000Z","updated":"2024-05-10T11:38:18.652Z","comments":true,"path":"2024/05/10/无敌暴龙队/","permalink":"https://zzx-dear.github.io/2024/05/10/%E6%97%A0%E6%95%8C%E6%9A%B4%E9%BE%99%E9%98%9F/","excerpt":"","text":"重生之我是占稳第一章：莫欺少年穷！第二章：莫欺中年穷！第三章：莫欺老年穷！","categories":[],"tags":[]}],"categories":[],"tags":[]}