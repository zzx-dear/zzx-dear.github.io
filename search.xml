<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>模式分解（一）无损连接性</title>
      <link href="/2024/05/20/%E6%9C%89%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E6%80%A7/"/>
      <url>/2024/05/20/%E6%9C%89%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="模式分解（一）无损连接性"><a href="#模式分解（一）无损连接性" class="headerlink" title="模式分解（一）无损连接性"></a>模式分解（一）无损连接性</h1><h2 id="定义：说人话就是-把不符合模式要求的大表分解成多个小表使符合要求"><a href="#定义：说人话就是-把不符合模式要求的大表分解成多个小表使符合要求" class="headerlink" title="定义：说人话就是 把不符合模式要求的大表分解成多个小表使符合要求"></a>定义：说人话就是 把不符合模式要求的大表分解成多个小表使符合要求</h2><p>特别注意：不能相互嵌套</p><p><strong>EG:</strong></p><p><img src="/2024/05/20/%E6%9C%89%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E6%80%A7/%E8%A1%A8%E4%B8%80.png" alt="表一"></p><p>R3嵌套于R2</p><h2 id="补充几种用到的连接"><a href="#补充几种用到的连接" class="headerlink" title="补充几种用到的连接"></a>补充几种用到的连接</h2><h3 id="（一）等值连接"><a href="#（一）等值连接" class="headerlink" title="（一）等值连接"></a>（一）等值连接</h3><p><img src="/2024/05/20/%E6%9C%89%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E6%80%A7/%E8%A1%A8%E4%BA%8C.png" alt="表二"></p><p>  <strong>比较的都是B属性 但是可以B和E进行等值连接</strong> <strong>等值连接必须要有等值条件</strong></p><h3 id="（二）自然连接"><a href="#（二）自然连接" class="headerlink" title="（二）自然连接"></a>（二）自然连接</h3><p>​自然连接是特殊的等值连接，<strong>必须要有相同的属性列</strong>。</p><h3 id="（三）在进行表连接时的两种情况"><a href="#（三）在进行表连接时的两种情况" class="headerlink" title="（三）在进行表连接时的两种情况"></a>（三）在进行表连接时的两种情况</h3><p>​1.有相同属性列 进行自然连接</p><p>​2.没有相同属性列 进行笛卡尔积连接</p><h2 id="表连接后的情况"><a href="#表连接后的情况" class="headerlink" title="表连接后的情况"></a>表连接后的情况</h2><p>​A大表分解出B小表和C小表   BC连接等到D表</p><p>​1. BC连接后的D表 一定包含大表A 数据只可能多，不可能少</p><p>​2. D表按照 A表分解的属性，分解后，得到的仍是BC两个小表</p><p>​3. D表与B表或C表连接后 仍是D表   </p><p>​<strong>如果D表和A表完全一样（数据不多不少）才证明有无损连接性</strong></p><p><img src="/2024/05/20/%E6%9C%89%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E6%80%A7/%E8%A1%A8%E4%B8%89.png" alt="表三"></p><p>从左向右前四个表依次是ABCD表 可带入思考一下</p><h2 id="判断无损链接的算法"><a href="#判断无损链接的算法" class="headerlink" title="判断无损链接的算法"></a>判断无损链接的算法</h2><h3 id="第一步：构建初始表"><a href="#第一步：构建初始表" class="headerlink" title="第一步：构建初始表"></a>第一步：构建初始表</h3><p><img src="/2024/05/20/%E6%9C%89%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E6%80%A7/%E8%A1%A8%E5%9B%9B.jpg" alt="表四"></p><p>表的行数取决于大表U的元素个数</p><p>表的列数取决去分解出的小表个数</p><p>在一行中如果对应小表存在此元素填入ai（i为列标） 不存在此元素填入bij（i为行标，j为列标）</p><h3 id="第二步：根据F中的函数依赖修改表的内容"><a href="#第二步：根据F中的函数依赖修改表的内容" class="headerlink" title="第二步：根据F中的函数依赖修改表的内容"></a>第二步：根据F中的函数依赖修改表的内容</h3><p>以R1表为例  函数依赖 C-&gt;D 由于R1中有c元素，所以可以得到D元素，把表中b14改为a4  </p><p>最终结果</p><p><img src="/2024/05/20/%E6%9C%89%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E6%80%A7/%E8%A1%A8%E4%BA%94.png" alt="表五"></p><h3 id="第三步：算法终止"><a href="#第三步：算法终止" class="headerlink" title="第三步：算法终止"></a>第三步：算法终止</h3><p>如果有一行全为a标签 算法终止 证明有无损连接性</p><p>根据F中函数依赖扫描前后 表无变化 算法终止 且没有一行全为a标签 证明没有无损连接性</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高斯数据库数据操作实例</title>
      <link href="/2024/05/14/%E9%AB%98%E6%96%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/"/>
      <url>/2024/05/14/%E9%AB%98%E6%96%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="高斯数据库-数据查询实例"><a href="#高斯数据库-数据查询实例" class="headerlink" title="高斯数据库 数据查询实例"></a><center>高斯数据库 数据查询实例</center></h1><h2 id="（一）-空值对结果的影响（例如在计算sum-avg-min集函数时系统如何处理空值属性）？"><a href="#（一）-空值对结果的影响（例如在计算sum-avg-min集函数时系统如何处理空值属性）？" class="headerlink" title="（一） 空值对结果的影响（例如在计算sum, avg, min集函数时系统如何处理空值属性）？"></a>（一） 空值对结果的影响（例如在计算sum, avg, min集函数时系统如何处理空值属性）？</h2><p><img src="/2024/05/14/%E9%AB%98%E6%96%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/1.png" alt="1"> </p><p>在gauss数据库中空值不做处理</p><h2 id="储备知识："><a href="#储备知识：" class="headerlink" title="*储备知识：*"></a><em><strong>*储备知识：*</strong></em></h2><h3 id="（一）索引的概念"><a href="#（一）索引的概念" class="headerlink" title="（一）索引的概念"></a>（一）索引的概念</h3><p>​索引（在MySQL中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构，这也是索引最基本的功能。</p><p>​索引对于良好的性能非常关键。数据量越大时，索引对性能的影响也越重要，好的索引可以将查询性能提高几个数量级。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但是在数据量逐渐增大时，糟糕的索引会使MySQL的性能急剧的下降。</p><p>​索引优化是查询性能优化最有效的手段。</p><p>​如果想要在一本书中找到某个特定主题，一般会先看书的目录，找到对应的页码，然后直接翻到对应的页码即可查看。存储引擎用类似的方法使用索引，首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。简单的说，数据库索引类似于书前面的目录，能加快数据库的查询速度。</p><h3 id="（二）索引的类别"><a href="#（二）索引的类别" class="headerlink" title="（二）索引的类别"></a>（二）索引的类别</h3><p>按照功能逻辑区分，目前主要有以下索引类型：</p><h4 id="1、主键索引"><a href="#1、主键索引" class="headerlink" title="1、主键索引"></a>1、主键索引</h4><p>​数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><p>ALTER TABLE table_name ADD PRIMARY KEY (column);</p><h4 id="2、普通索引"><a href="#2、普通索引" class="headerlink" title="2、普通索引"></a>2、普通索引</h4><p>​MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和NULL值。一个表允许多个列创建普通索引。</p><p>ALTER TABLE table_name ADD INDEX index_name (column);</p><h4 id="3、唯一索引"><a href="#3、唯一索引" class="headerlink" title="3、唯一索引"></a>3、唯一索引</h4><p>​索引列中的值必须是唯一的，但是允许NULL值。建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。一个表允许多个列创建唯一索引。</p><p>ALTER TABLE table_name ADD UNIQUE (column);</p><h4 id="4、全文索引"><a href="#4、全文索引" class="headerlink" title="4、全文索引"></a>4、全文索引</h4><p>​主要是为了快速检索大文本数据中的关键字的信息。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引，基于倒排索引，类似于搜索引擎。</p><p>ALTER TABLE table_name ADD FULLTEXT (column);</p><h4 id="5、前缀索引"><a href="#5、前缀索引" class="headerlink" title="5、前缀索引"></a>5、前缀索引</h4><p>​在文本类型如BLOB、TEXT或者很长的VARCHAR列上创建索引时，可以使用前缀索引，数据量相比普通索引更小，可以指定索引列的长度，但是数值类型不能指定。</p><p>ALTER TABLE table_name ADD KEY(column_name(prefix_length));</p><h4 id="6、组合索引"><a href="#6、组合索引" class="headerlink" title="6、组合索引"></a>6、组合索引</h4><p>​指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀原则。</p><p>主键索引、普通索引、唯一索引等都可以使用多个字段形成组合索引。例如，ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3 );</p><h3 id="（三）非聚簇索引与聚簇索引的区别"><a href="#（三）非聚簇索引与聚簇索引的区别" class="headerlink" title="（三）非聚簇索引与聚簇索引的区别"></a>（三）非聚簇索引与聚簇索引的区别</h3><p>聚簇索引和非聚簇索引的主要区别在于它们的存储方式、查找效率以及数据行修改的影响。</p><ol><li>存储方式不同：聚簇索引的叶子节点直接包含了数据行，这意味着数据和索引在一起存储。在InnoDB中，主键默认就是聚簇索引。非聚簇索引的数据行和索引结构是分开存储的，叶子节点包含指向数据行的指针。</li><li>查找效率不同：聚簇索引由于其数据和索引紧耦合的特性，在查找特定值或范围的查询时非常高效。非聚簇索引在查找数据时需要进行额外的物理读取，因此在某些情况下会比聚簇索引慢一些。</li><li>数据行修改的影响不同：当数据行发生修改时，聚簇索引可能需要移动或调整相应的数据行位置，这可能会导致页分裂等问题。而非聚簇索引只需更新索引树和数据页，不会影响到其他数据行的位置。</li></ol><p>​此外，在MySQL的InnoDB存储引擎中，除了主键作为聚簇索引外，其他创建的索引如复合索引、前缀索引、唯一索引等都是非聚簇索引，也被称为辅助索引。这些辅助索引的叶子节点存储的不是数据的物理位置，而是主键值，通过主键值再去查找实际的数据行。</p><p>​综上所述，聚簇索引和非聚簇索引在存储方式、查找效率等方面上有明显的差异。聚簇索引适合用于频繁访问的数据，而非聚簇索引则适用于插入操作频繁的场景。在设计数据库表和索引时，需要根据具体的应用场景和查询需求来选择合适的索引类型。</p><h2 id="（二）注意查看查询执行计划：如果查看的属性列上有索引和没有索引，系统是读取数据的方式有何不同？"><a href="#（二）注意查看查询执行计划：如果查看的属性列上有索引和没有索引，系统是读取数据的方式有何不同？" class="headerlink" title="（二）注意查看查询执行计划：如果查看的属性列上有索引和没有索引，系统是读取数据的方式有何不同？"></a>（二）注意查看查询执行计划：如果查看的属性列上有索引和没有索引，系统是读取数据的方式有何不同？</h2><p>Clsnum列上没有索引时：</p><p> <img src="/2024/05/14/%E9%AB%98%E6%96%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/2.png" alt="2"></p><p>根据这个执行计划，我们可以知道这个查询是一个全表扫描，针对GAUSSDBTEST用户的CLASS表进行操作。</p><p>为Clsnum列上创建索引后（CREATE INDEX index_clsnum ON class(clsnum);）：</p><p><img src="/2024/05/14/%E9%AB%98%E6%96%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/3.png" alt="3"> </p><p>根据这个执行计划，可以推断出以下信息：</p><p>1、这个查询是通过使用名为INDEX_CLSNUM的索引来访问名为CLASS的表。</p><p>2、索引访问方式是FAST FULL SCAN，即快速全扫描，这通常意味着将扫描整个索引以找到匹配的行。</p><p><em><strong>*例外：在有些数据库中如果一个表上建立了一个索引，那么在这个表上的所有查询都将是索引查询，都会利用这个索引去读取表中的数据，不管索引所属于的属性列是否被涉及。*</strong></em></p><h2 id="（三）为什么有时候即使使用了Order-by操作，但查询计划里并没有相应的操作？对于distinct也有类似的情况。"><a href="#（三）为什么有时候即使使用了Order-by操作，但查询计划里并没有相应的操作？对于distinct也有类似的情况。" class="headerlink" title="（三）为什么有时候即使使用了Order by操作，但查询计划里并没有相应的操作？对于distinct也有类似的情况。"></a>（三）为什么有时候即使使用了Order by操作，但查询计划里并没有相应的操作？对于distinct也有类似的情况。</h2><p>  用主键clsno作为Order by的条件时，在执行计划中会发现并没有执行Order by操作；</p><p><img src="/2024/05/14/%E9%AB%98%E6%96%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/4.png" alt="4"> </p><p>利用tchno作为order by的条件的时候，在执行计划里就会有相应order by的操作。</p><p><img src="/2024/05/14/%E9%AB%98%E6%96%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/5.png" alt="5"> </p><pre><code> 从上面两个对比，我们可以知道，当order by后面的属性上已经有索引使数据按照顺序存放的时候，再用order by不会再执行一次排序工作；但是当order by后面的属性列上没有相应的约束时，当这个属性列作为order by的条件，会进行一次sort排序工作。</code></pre><h2 id="（四）对于distinct的情况：如果要求distinct的属性列上已经没有是没有重复的了，那么就不会再执行一次distinct操作；如果这个属性列上本身并没有使它不重复的约束，那么会执行一次distinct操作。"><a href="#（四）对于distinct的情况：如果要求distinct的属性列上已经没有是没有重复的了，那么就不会再执行一次distinct操作；如果这个属性列上本身并没有使它不重复的约束，那么会执行一次distinct操作。" class="headerlink" title="（四）对于distinct的情况：如果要求distinct的属性列上已经没有是没有重复的了，那么就不会再执行一次distinct操作；如果这个属性列上本身并没有使它不重复的约束，那么会执行一次distinct操作。"></a>（四）对于distinct的情况：如果要求distinct的属性列上已经没有是没有重复的了，那么就不会再执行一次distinct操作；如果这个属性列上本身并没有使它不重复的约束，那么会执行一次distinct操作。</h2><p>（没有使它不重复的约束）</p><p><img src="/2024/05/14/%E9%AB%98%E6%96%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/6.png" alt="6"> </p><p>（添加后）</p><p> <img src="/2024/05/14/%E9%AB%98%E6%96%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/7.png" alt="7"></p><h2 id="（五）关于链接查询"><a href="#（五）关于链接查询" class="headerlink" title="（五）关于链接查询"></a>（五）关于链接查询</h2><p>​通过查询相关信息我们知道，系统只辨别等值连接，如果要进行自然连接，我们应该在查询语句中自己输入好select的条件，例如我们上面写出elective.courNo,elective.elcTime,elective.elcGrade，而不是只写出elective.*，由系统去辨别这是自然连接，然后执行查询。等值连接和自然连接是数据库中用于关联两个表的两种不同的连接方式。具体区别如下：</p><ol><li>连接条件：等值连接不要求连接的属性值完全相同，而自然连接要求进行比较的两个关系中必须有相同的属性组，即值域必须相同。</li><li>重复属性处理：等值连接不会去掉重复属性，而自然连接会去掉重复的属性列。这意味着自然连接实际上是去除了重复列的等值连接。</li><li>公共属性要求：等值连接要求相等的分量，不一定是公共属性；而自然连接要求相等的分量必须是公共属性。</li><li>操作结果：自然连接在等值连接的基础上进行投影操作，去掉了S中的公共属性列。当两个关系没有公共属性时，自然连接就转化成笛卡尔积。</li></ol><p>​总的来说，自然连接是一种特殊类型的等值连接，它在等值连接的基础上进行了额外的属性去除操作。在实际使用中，根据查询需求的不同选择合适的连接类型是非常重要的。</p><p>相关嵌套查询和非相关嵌套查询是SQL中两种常见的嵌套查询方式。</p><ol><li><h3 id="相关嵌套查询（Correlated-Nested-Query）："><a href="#相关嵌套查询（Correlated-Nested-Query）：" class="headerlink" title="相关嵌套查询（Correlated Nested Query）："></a>相关嵌套查询（Correlated Nested Query）：</h3></li></ol><p>  - 相关嵌套查询是指子查询的结果依赖于外部查询的某个值或条件。</p><p>  - 在执行相关嵌套查询时，外部查询的每一行都会执行一次子查询，因此可能导致性能问题。</p><ol start="2"><li><h3 id="非相关嵌套查询（Non-correlated-Nested-Query）："><a href="#非相关嵌套查询（Non-correlated-Nested-Query）：" class="headerlink" title="非相关嵌套查询（Non-correlated Nested Query）："></a>非相关嵌套查询（Non-correlated Nested Query）：</h3></li></ol><p>  - 非相关嵌套查询是指子查询的结果不依赖于外部查询的任何值或条件。</p><p>  - 在执行非相关嵌套查询时，子查询只会执行一次，然后将结果用于外部查询。</p><p> 总结：相关嵌套查询和非相关嵌套查询的主要区别在于子查询的结果是否依赖于外部查询的值或条件。相关嵌套查询可能导致性能问题，而非相关嵌套查询则更加高效。</p><p>IN、EXISTS、ANY、ALL和SOME在SQL中都是用来处理子查询的关键字，它们之间存在一定的等价关系。以下是具体的分析：</p><p>- <strong>IN</strong>：当主查询中的值在子查询返回的结果集中时，IN条件为真。它相当于使用等于（&#x3D;）比较运算符与子查询结果集中的每一个值进行比较。</p><p>- <strong>EXISTS</strong>：当子查询至少返回一行数据时，EXISTS条件为真。它不对子查询的结果集进行缓存，只关心是否有结果返回。如果子查询没有返回任何行，EXISTS返回false。</p><p>- <strong>ANY（或SOME）</strong>：当主查询中的值满足子查询结果集中的任何一个值时，ANY（或SOME）条件为真。它相当于使用比较运算符（如&#x3D;、&gt;、&lt;等）与子查询结果集中的每一个值进行比较。</p><p>- <strong>ALL</strong>：当主查询中的值满足子查询结果集中所有值的条件时，ALL条件为真。它要求主查询中的值必须同时满足子查询结果集中所有值的比较条件。</p><p>​总的来说，这些关键字在处理子查询时有着不同的应用场景和效率考虑，选择合适的关键字可以帮助提高查询的性能。在实际使用时，需要根据具体的数据和查询需求来选择最合适的关键字。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>无敌暴龙队</title>
      <link href="/2024/05/10/%E6%97%A0%E6%95%8C%E6%9A%B4%E9%BE%99%E9%98%9F/"/>
      <url>/2024/05/10/%E6%97%A0%E6%95%8C%E6%9A%B4%E9%BE%99%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="重生之我是占稳"><a href="#重生之我是占稳" class="headerlink" title="重生之我是占稳"></a>重生之我是占稳</h2><p>第一章：莫欺少年穷！<br>第二章：莫欺中年穷！<br>第三章：莫欺老年穷！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
